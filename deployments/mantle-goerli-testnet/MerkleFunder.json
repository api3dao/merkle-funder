{
  "address": "0x04d2B3DdCdb2790571Ca01F4768e3cC98FCb0D2B",
  "abi": [
    {
      "inputs": [],
      "name": "AmountZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "HighThresholdZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidProof",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LowThresholdHigherThanHigh",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoSuchMerkleFunderDepository",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RecipientAddressZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RecipientBalanceLargerThanLowThreshold",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootZero",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "merkleFunderDepository",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        }
      ],
      "name": "DeployedMerkleFunderDepository",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "merkleFunderDepository",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Funded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "merkleFunderDepository",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Withdrew",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        }
      ],
      "name": "computeMerkleFunderDepositoryAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "merkleFunderDepository",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "containsBytecode",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        }
      ],
      "name": "deployMerkleFunderDepository",
      "outputs": [
        {
          "internalType": "address payable",
          "name": "merkleFunderDepository",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "lowThreshold",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "highThreshold",
          "type": "uint256"
        }
      ],
      "name": "fund",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "getBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBlockBasefee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBlockNumber",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBlockTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getChainId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "returndata",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "ownerToRootToMerkleFunderDepositoryAddress",
      "outputs": [
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "tryMulticall",
      "outputs": [
        {
          "internalType": "bool[]",
          "name": "successes",
          "type": "bool[]"
        },
        {
          "internalType": "bytes[]",
          "name": "returndata",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "withdrawAll",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x4fe6e43d3c80da403499d8a009a93e6584809304d6efe0b71616e72f0009fec7",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x07b589f06bD0A5324c4E2376d66d2F4F25921DE1",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "1144065",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x771c5b8339d86e53a96e65b33a32034683cb1b38390f0a8b7d46bc201bfdbc3b",
    "transactionHash": "0x4fe6e43d3c80da403499d8a009a93e6584809304d6efe0b71616e72f0009fec7",
    "logs": [],
    "blockNumber": 20314132,
    "cumulativeGasUsed": "1144065",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "1ea0028e4c45b95e14f60a837d4b2de4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AmountZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HighThresholdZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LowThresholdHigherThanHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSuchMerkleFunderDepository\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RecipientAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RecipientBalanceLargerThanLowThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"DeployedMerkleFunderDepository\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrew\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"computeMerkleFunderDepositoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"containsBytecode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"deployMerkleFunderDepository\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"merkleFunderDepository\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lowThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highThreshold\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockBasefee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"returndata\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ownerToRootToMerkleFunderDepositoryAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"tryMulticall\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"successes\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"returndata\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"MerkleFunder inherits SelfMulticall to allow `fund()` to be multi-called so that multiple fundings can be executed in a single transaction without depending on an external contract. Furthermore, it inherits ExtendedSelfMulticall to allow `getBlockNumber()` be multi-called to avoid race conditions that would have caused the bot implementation to make redundant transactions that revert.\",\"kind\":\"dev\",\"methods\":{\"computeMerkleFunderDepositoryAddress(address,bytes32)\":{\"params\":{\"owner\":\"Owner address\",\"root\":\"Merkle tree root\"},\"returns\":{\"merkleFunderDepository\":\"MerkleFunderDepository address\"}},\"containsBytecode(address)\":{\"details\":\"An account not containing any bytecode does not indicate that it is an EOA or it will not contain any bytecode in the future. Contract construction and `SELFDESTRUCT` updates the bytecode at the end of the transaction.\",\"returns\":{\"_0\":\"If the account contains bytecode\"}},\"deployMerkleFunderDepository(address,bytes32)\":{\"details\":\"The owner address is allowed to be zero in case the deployer wants to disallow `withdraw()` from being called for the respective MerkleFunderDepository. See `fund()` for how the Merkle tree leaves are derived and how the comprising parameters are validated.\",\"params\":{\"owner\":\"Owner address\",\"root\":\"Merkle tree root\"},\"returns\":{\"merkleFunderDepository\":\"MerkleFunderDepository address\"}},\"fund(address,bytes32,bytes32[],address,uint256,uint256)\":{\"params\":{\"highThreshold\":\"High hysteresis threshold\",\"lowThreshold\":\"Low hysteresis threshold\",\"owner\":\"Owner address\",\"proof\":\"Merkle tree proof\",\"recipient\":\"Recipient address\",\"root\":\"Merkle tree root\"},\"returns\":{\"amount\":\"Amount used in funding\"}},\"getBalance(address)\":{\"params\":{\"account\":\"Account address\"},\"returns\":{\"_0\":\"Account balance\"}},\"getBlockBasefee()\":{\"returns\":{\"_0\":\"Current block basefee\"}},\"getBlockNumber()\":{\"returns\":{\"_0\":\"Current block number\"}},\"getBlockTimestamp()\":{\"returns\":{\"_0\":\"Current block timestamp\"}},\"getChainId()\":{\"returns\":{\"_0\":\"Chain ID\"}},\"multicall(bytes[])\":{\"params\":{\"data\":\"Array of calldata of batched calls\"},\"returns\":{\"returndata\":\"Array of returndata of batched calls\"}},\"tryMulticall(bytes[])\":{\"params\":{\"data\":\"Array of calldata of batched calls\"},\"returns\":{\"returndata\":\"Array of returndata of batched calls\",\"successes\":\"Array of success conditions of batched calls\"}},\"withdraw(bytes32,address,uint256)\":{\"params\":{\"amount\":\"Withdrawal amount\",\"recipient\":\"Recipient address\",\"root\":\"Merkle tree root\"}},\"withdrawAll(bytes32,address)\":{\"params\":{\"recipient\":\"Recipient address\",\"root\":\"Merkle tree root\"},\"returns\":{\"amount\":\"Withdrawal amount\"}}},\"stateVariables\":{\"ownerToRootToMerkleFunderDepositoryAddress\":{\"details\":\"The MerkleFunderDepository address can be derived from the owner address and the Merkle tree root using `computeMerkleFunderDepositoryAddress()`, yet doing so is more expensive than reading it from this mapping, which is why we prefer storing it during deployment\"}},\"title\":\"Contract that can be called to deploy MerkleFunderDepository contracts or transfer the funds in them within the limitations specified by the respective Merkle trees\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"computeMerkleFunderDepositoryAddress(address,bytes32)\":{\"notice\":\"Computes the address of the MerkleFunderDepository\"},\"containsBytecode(address)\":{\"notice\":\"Returns if the account contains bytecode\"},\"deployMerkleFunderDepository(address,bytes32)\":{\"notice\":\"Called to deterministically deploy the MerkleFunderDepository with the owner address and the Merkle tree root\"},\"fund(address,bytes32,bytes32[],address,uint256,uint256)\":{\"notice\":\"Called to transfer funds from a MerkleFunderDepository to the recipient within the limitations specified by the respective Merkle tree\"},\"getBalance(address)\":{\"notice\":\"Returns the account balance\"},\"getBlockBasefee()\":{\"notice\":\"Returns the current block basefee\"},\"getBlockNumber()\":{\"notice\":\"Returns the current block number\"},\"getBlockTimestamp()\":{\"notice\":\"Returns the current block timestamp\"},\"getChainId()\":{\"notice\":\"Returns the chain ID\"},\"multicall(bytes[])\":{\"notice\":\"Batches calls to the inheriting contract and reverts as soon as one of the batched calls reverts\"},\"ownerToRootToMerkleFunderDepositoryAddress(address,bytes32)\":{\"notice\":\"Returns the address of the MerkleFunderDepository deployed for the owner address and the Merkle tree root, and zero-address if such a MerkleFunderDepository is not deployed yet\"},\"tryMulticall(bytes[])\":{\"notice\":\"Batches calls to the inheriting contract but does not revert if any of the batched calls reverts\"},\"withdraw(bytes32,address,uint256)\":{\"notice\":\"Called by the owner of the respective MerkleFunderDepository to withdraw funds in a way that is exempt from the limitations specified by the respective Merkle tree\"},\"withdrawAll(bytes32,address)\":{\"notice\":\"Called by the owner of the respective MerkleFunderDepository to withdraw its entire balance in a way that is exempt from the limitations specified by the respective Merkle tree\"}},\"notice\":\"Use-cases such as self-funded data feeds require users to keep multiple accounts funded. The only way to achieve this without relying on on-chain activity is running a bot that triggers the funding using a hot wallet. In the naive implementation, the funds to be used would also be kept by this hot wallet, which is obviously risky. This contract allows one to deploy a MerkleFunderDepository where they can keep the funds, which this contract only allows to be transferred within the limitations specified by the respective Merkle tree. This means the bot's hot wallet no longer needs to be trusted with the funds, and multiple bots with different hot wallets can be run against the same MerkleFunderDepository deployment for redundancy.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MerkleFunder.sol\":\"MerkleFunder\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@api3/airnode-protocol-v1/contracts/utils/ExtendedSelfMulticall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./SelfMulticall.sol\\\";\\nimport \\\"./interfaces/IExtendedSelfMulticall.sol\\\";\\n\\n/// @title Contract that extends SelfMulticall to fetch some of the global\\n/// variables\\n/// @notice Available global variables are limited to the ones that Airnode\\n/// tends to need\\ncontract ExtendedSelfMulticall is SelfMulticall, IExtendedSelfMulticall {\\n    /// @notice Returns the chain ID\\n    /// @return Chain ID\\n    function getChainId() external view override returns (uint256) {\\n        return block.chainid;\\n    }\\n\\n    /// @notice Returns the account balance\\n    /// @param account Account address\\n    /// @return Account balance\\n    function getBalance(\\n        address account\\n    ) external view override returns (uint256) {\\n        return account.balance;\\n    }\\n\\n    /// @notice Returns if the account contains bytecode\\n    /// @dev An account not containing any bytecode does not indicate that it\\n    /// is an EOA or it will not contain any bytecode in the future.\\n    /// Contract construction and `SELFDESTRUCT` updates the bytecode at the\\n    /// end of the transaction.\\n    /// @return If the account contains bytecode\\n    function containsBytecode(\\n        address account\\n    ) external view override returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    /// @notice Returns the current block number\\n    /// @return Current block number\\n    function getBlockNumber() external view override returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /// @notice Returns the current block timestamp\\n    /// @return Current block timestamp\\n    function getBlockTimestamp() external view override returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /// @notice Returns the current block basefee\\n    /// @return Current block basefee\\n    function getBlockBasefee() external view override returns (uint256) {\\n        return block.basefee;\\n    }\\n}\\n\",\"keccak256\":\"0xada4020386f51e076953a110accf21efc53b82858bb88fc6725591556d86574b\",\"license\":\"MIT\"},\"@api3/airnode-protocol-v1/contracts/utils/SelfMulticall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/ISelfMulticall.sol\\\";\\n\\n/// @title Contract that enables calls to the inheriting contract to be batched\\n/// @notice Implements two ways of batching, one requires none of the calls to\\n/// revert and the other tolerates individual calls reverting\\n/// @dev This implementation uses delegatecall for individual function calls.\\n/// Since delegatecall is a message call, it can only be made to functions that\\n/// are externally visible. This means that a contract cannot multicall its own\\n/// functions that use internal/private visibility modifiers.\\n/// Refer to OpenZeppelin's Multicall.sol for a similar implementation.\\ncontract SelfMulticall is ISelfMulticall {\\n    /// @notice Batches calls to the inheriting contract and reverts as soon as\\n    /// one of the batched calls reverts\\n    /// @param data Array of calldata of batched calls\\n    /// @return returndata Array of returndata of batched calls\\n    function multicall(\\n        bytes[] calldata data\\n    ) external override returns (bytes[] memory returndata) {\\n        uint256 callCount = data.length;\\n        returndata = new bytes[](callCount);\\n        for (uint256 ind = 0; ind < callCount; ) {\\n            bool success;\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (success, returndata[ind]) = address(this).delegatecall(data[ind]);\\n            if (!success) {\\n                bytes memory returndataWithRevertData = returndata[ind];\\n                if (returndataWithRevertData.length > 0) {\\n                    // Adapted from OpenZeppelin's Address.sol\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        let returndata_size := mload(returndataWithRevertData)\\n                        revert(\\n                            add(32, returndataWithRevertData),\\n                            returndata_size\\n                        )\\n                    }\\n                } else {\\n                    revert(\\\"Multicall: No revert string\\\");\\n                }\\n            }\\n            unchecked {\\n                ind++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Batches calls to the inheriting contract but does not revert if\\n    /// any of the batched calls reverts\\n    /// @param data Array of calldata of batched calls\\n    /// @return successes Array of success conditions of batched calls\\n    /// @return returndata Array of returndata of batched calls\\n    function tryMulticall(\\n        bytes[] calldata data\\n    )\\n        external\\n        override\\n        returns (bool[] memory successes, bytes[] memory returndata)\\n    {\\n        uint256 callCount = data.length;\\n        successes = new bool[](callCount);\\n        returndata = new bytes[](callCount);\\n        for (uint256 ind = 0; ind < callCount; ) {\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (successes[ind], returndata[ind]) = address(this).delegatecall(\\n                data[ind]\\n            );\\n            unchecked {\\n                ind++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb466760f7b5d05a91fb168224952f29db9aa3308f0b83535fd697f3c30281740\",\"license\":\"MIT\"},\"@api3/airnode-protocol-v1/contracts/utils/interfaces/IExtendedSelfMulticall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ISelfMulticall.sol\\\";\\n\\ninterface IExtendedSelfMulticall is ISelfMulticall {\\n    function getChainId() external view returns (uint256);\\n\\n    function getBalance(address account) external view returns (uint256);\\n\\n    function containsBytecode(address account) external view returns (bool);\\n\\n    function getBlockNumber() external view returns (uint256);\\n\\n    function getBlockTimestamp() external view returns (uint256);\\n\\n    function getBlockBasefee() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xaefe61a623c920d3e39c4779535e280378b44202d11c29a2c96f46f2fe5f420d\",\"license\":\"MIT\"},\"@api3/airnode-protocol-v1/contracts/utils/interfaces/ISelfMulticall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ISelfMulticall {\\n    function multicall(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory returndata);\\n\\n    function tryMulticall(\\n        bytes[] calldata data\\n    ) external returns (bool[] memory successes, bytes[] memory returndata);\\n}\\n\",\"keccak256\":\"0x50b27284f0d5acd8b340836c09d252138ebf059f426e5d90d3f7221e1b7d0817\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xafc07f37809f74d9c66d6461cc0f85fb5147ab855acd0acc30af4b2272130c61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd466e8b07f4c6220eac16da5127f3ff142e65f0c15c03c7d38f257b02c8585e1\",\"license\":\"MIT\"},\"contracts/MerkleFunder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@api3/airnode-protocol-v1/contracts/utils/ExtendedSelfMulticall.sol\\\";\\nimport \\\"./interfaces/IMerkleFunder.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"./MerkleFunderDepository.sol\\\";\\n\\n/// @title Contract that can be called to deploy MerkleFunderDepository\\n/// contracts or transfer the funds in them within the limitations specified by\\n/// the respective Merkle trees\\n/// @notice Use-cases such as self-funded data feeds require users to keep\\n/// multiple accounts funded. The only way to achieve this without relying on\\n/// on-chain activity is running a bot that triggers the funding using a hot\\n/// wallet. In the naive implementation, the funds to be used would also be\\n/// kept by this hot wallet, which is obviously risky. This contract allows one\\n/// to deploy a MerkleFunderDepository where they can keep the funds, which\\n/// this contract only allows to be transferred within the limitations\\n/// specified by the respective Merkle tree. This means the bot's hot wallet no\\n/// longer needs to be trusted with the funds, and multiple bots with different\\n/// hot wallets can be run against the same MerkleFunderDepository deployment\\n/// for redundancy.\\n/// @dev MerkleFunder inherits SelfMulticall to allow `fund()` to be\\n/// multi-called so that multiple fundings can be executed in a single\\n/// transaction without depending on an external contract. Furthermore, it\\n/// inherits ExtendedSelfMulticall to allow `getBlockNumber()` be multi-called\\n/// to avoid race conditions that would have caused the bot implementation to\\n/// make redundant transactions that revert.\\ncontract MerkleFunder is ExtendedSelfMulticall, IMerkleFunder {\\n    /// @notice Returns the address of the MerkleFunderDepository deployed for\\n    /// the owner address and the Merkle tree root, and zero-address if such a\\n    /// MerkleFunderDepository is not deployed yet\\n    /// @dev The MerkleFunderDepository address can be derived from the owner\\n    /// address and the Merkle tree root using\\n    /// `computeMerkleFunderDepositoryAddress()`, yet doing so is more\\n    /// expensive than reading it from this mapping, which is why we prefer\\n    /// storing it during deployment\\n    mapping(address => mapping(bytes32 => address payable))\\n        public\\n        override ownerToRootToMerkleFunderDepositoryAddress;\\n\\n    /// @notice Called to deterministically deploy the MerkleFunderDepository\\n    /// with the owner address and the Merkle tree root\\n    /// @dev The owner address is allowed to be zero in case the deployer wants\\n    /// to disallow `withdraw()` from being called for the respective\\n    /// MerkleFunderDepository.\\n    /// See `fund()` for how the Merkle tree leaves are derived and how the\\n    /// comprising parameters are validated.\\n    /// @param owner Owner address\\n    /// @param root Merkle tree root\\n    /// @return merkleFunderDepository MerkleFunderDepository address\\n    function deployMerkleFunderDepository(\\n        address owner,\\n        bytes32 root\\n    ) external override returns (address payable merkleFunderDepository) {\\n        if (root == bytes32(0)) revert RootZero();\\n        merkleFunderDepository = payable(\\n            new MerkleFunderDepository{salt: bytes32(0)}(owner, root)\\n        );\\n        ownerToRootToMerkleFunderDepositoryAddress[owner][\\n            root\\n        ] = merkleFunderDepository;\\n        emit DeployedMerkleFunderDepository(\\n            merkleFunderDepository,\\n            owner,\\n            root\\n        );\\n    }\\n\\n    /// @notice Called to transfer funds from a MerkleFunderDepository to the\\n    /// recipient within the limitations specified by the respective Merkle\\n    /// tree\\n    /// @param owner Owner address\\n    /// @param root Merkle tree root\\n    /// @param proof Merkle tree proof\\n    /// @param recipient Recipient address\\n    /// @param lowThreshold Low hysteresis threshold\\n    /// @param highThreshold High hysteresis threshold\\n    /// @return amount Amount used in funding\\n    function fund(\\n        address owner,\\n        bytes32 root,\\n        bytes32[] calldata proof,\\n        address recipient,\\n        uint256 lowThreshold,\\n        uint256 highThreshold\\n    ) external override returns (uint256 amount) {\\n        if (recipient == address(0)) revert RecipientAddressZero();\\n        if (lowThreshold > highThreshold) revert LowThresholdHigherThanHigh();\\n        if (highThreshold == 0) revert HighThresholdZero();\\n        bytes32 leaf = keccak256(\\n            bytes.concat(\\n                keccak256(abi.encode(recipient, lowThreshold, highThreshold))\\n            )\\n        );\\n        if (!MerkleProof.verify(proof, root, leaf)) revert InvalidProof();\\n        uint256 recipientBalance = recipient.balance;\\n        if (recipientBalance > lowThreshold)\\n            revert RecipientBalanceLargerThanLowThreshold();\\n        address payable merkleFunderDepository = ownerToRootToMerkleFunderDepositoryAddress[\\n                owner\\n            ][root];\\n        if (merkleFunderDepository == address(0))\\n            revert NoSuchMerkleFunderDepository();\\n        uint256 amountNeededToTopUp;\\n        unchecked {\\n            amountNeededToTopUp = highThreshold - recipientBalance;\\n        }\\n        amount = amountNeededToTopUp <= merkleFunderDepository.balance\\n            ? amountNeededToTopUp\\n            : merkleFunderDepository.balance;\\n        if (amount == 0) revert AmountZero();\\n        MerkleFunderDepository(merkleFunderDepository).transfer(\\n            recipient,\\n            amount\\n        );\\n        emit Funded(merkleFunderDepository, recipient, amount);\\n    }\\n\\n    /// @notice Called by the owner of the respective MerkleFunderDepository to\\n    /// withdraw funds in a way that is exempt from the limitations specified\\n    /// by the respective Merkle tree\\n    /// @param root Merkle tree root\\n    /// @param recipient Recipient address\\n    /// @param amount Withdrawal amount\\n    function withdraw(\\n        bytes32 root,\\n        address recipient,\\n        uint256 amount\\n    ) public override {\\n        if (recipient == address(0)) revert RecipientAddressZero();\\n        if (amount == 0) revert AmountZero();\\n        address payable merkleFunderDepository = ownerToRootToMerkleFunderDepositoryAddress[\\n                msg.sender\\n            ][root];\\n        if (merkleFunderDepository == address(0))\\n            revert NoSuchMerkleFunderDepository();\\n        if (merkleFunderDepository.balance < amount)\\n            revert InsufficientBalance();\\n        MerkleFunderDepository(merkleFunderDepository).transfer(\\n            recipient,\\n            amount\\n        );\\n        emit Withdrew(merkleFunderDepository, recipient, amount);\\n    }\\n\\n    /// @notice Called by the owner of the respective MerkleFunderDepository to\\n    /// withdraw its entire balance in a way that is exempt from the\\n    /// limitations specified by the respective Merkle tree\\n    /// @param root Merkle tree root\\n    /// @param recipient Recipient address\\n    /// @return amount Withdrawal amount\\n    function withdrawAll(\\n        bytes32 root,\\n        address recipient\\n    ) external override returns (uint256 amount) {\\n        amount = ownerToRootToMerkleFunderDepositoryAddress[msg.sender][root]\\n            .balance;\\n        withdraw(root, recipient, amount);\\n    }\\n\\n    /// @notice Computes the address of the MerkleFunderDepository\\n    /// @param owner Owner address\\n    /// @param root Merkle tree root\\n    /// @return merkleFunderDepository MerkleFunderDepository address\\n    function computeMerkleFunderDepositoryAddress(\\n        address owner,\\n        bytes32 root\\n    ) external view override returns (address merkleFunderDepository) {\\n        if (root == bytes32(0)) revert RootZero();\\n        merkleFunderDepository = Create2.computeAddress(\\n            bytes32(0),\\n            keccak256(\\n                abi.encodePacked(\\n                    type(MerkleFunderDepository).creationCode,\\n                    abi.encode(owner, root)\\n                )\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xe220809bbe66045d39187c43ff6a2ccd487a4088a2538bd2c397c6c951bba35f\",\"license\":\"MIT\"},\"contracts/MerkleFunderDepository.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./interfaces/IMerkleFunderDepository.sol\\\";\\n\\n/// @title Contract that is deployed through MerkleFunder and keeps the funds\\n/// that can be transferred within the limitations specified by the respective\\n/// Merkle tree\\n/// @notice As noted above, this contract should only be deployed by a\\n/// MerkleFunder contract. Since the owner address and the Merkle tree root are\\n/// immutable, the only way to update these is to deploy a new\\n/// MerkleFunderDepository with the desired parameters and have the owner of\\n/// the previous MerkleFunderDepository withdraw the funds to the new one.\\ncontract MerkleFunderDepository is IMerkleFunderDepository {\\n    /// @notice Address of the MerkleFunder that deployed this contract\\n    address public immutable override merkleFunder;\\n\\n    /// @notice Owner address\\n    address public immutable override owner;\\n\\n    /// @notice Merkle tree root\\n    bytes32 public immutable override root;\\n\\n    /// @dev Argument validation is done in MerkleFunder to reduce the\\n    /// bytecode of this contract\\n    /// @param _owner Owner address\\n    /// @param _root Merkle tree root\\n    constructor(address _owner, bytes32 _root) {\\n        merkleFunder = msg.sender;\\n        owner = _owner;\\n        root = _root;\\n    }\\n\\n    /// @dev Funds transferred to this contract can be transferred by anyone\\n    /// within the limitations of the respective Merkle tree\\n    receive() external payable {}\\n\\n    /// @notice Called by the MerkleFunder that has deployed this contract to\\n    /// transfer its funds within the limitations of the respective Merkle tree\\n    /// or to allow the owner to withdraw funds\\n    /// @dev Argument validation is done in MerkleFunder to reduce the bytecode\\n    /// of this contract.\\n    /// This function is omitted in the interface because it is intended to\\n    /// only be called by MerkleFunder.\\n    /// @param recipient Recipient address\\n    /// @param amount Amount\\n    function transfer(address recipient, uint256 amount) external {\\n        if (msg.sender != merkleFunder) revert SenderNotMerkleFunder();\\n        // MerkleFunder checks for balance so MerkleFunderDepository does not\\n        // need to\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) revert TransferUnsuccessful();\\n        // MerkleFunder emits the event so MerkleFunderDepository does not need\\n        // to\\n    }\\n}\\n\",\"keccak256\":\"0x7db1c9e9e991bb42720e8f4217d5d10c381835f96b4eceffe1bb232a07147ab3\",\"license\":\"MIT\"},\"contracts/interfaces/IMerkleFunder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@api3/airnode-protocol-v1/contracts/utils/interfaces/IExtendedSelfMulticall.sol\\\";\\n\\ninterface IMerkleFunder is IExtendedSelfMulticall {\\n    event DeployedMerkleFunderDepository(\\n        address indexed merkleFunderDepository,\\n        address owner,\\n        bytes32 root\\n    );\\n\\n    event Funded(\\n        address indexed merkleFunderDepository,\\n        address recipient,\\n        uint256 amount\\n    );\\n\\n    event Withdrew(\\n        address indexed merkleFunderDepository,\\n        address recipient,\\n        uint256 amount\\n    );\\n\\n    error RootZero();\\n\\n    error RecipientAddressZero();\\n\\n    error LowThresholdHigherThanHigh();\\n\\n    error HighThresholdZero();\\n\\n    error InvalidProof();\\n\\n    error RecipientBalanceLargerThanLowThreshold();\\n\\n    error NoSuchMerkleFunderDepository();\\n\\n    error AmountZero();\\n\\n    error InsufficientBalance();\\n\\n    function deployMerkleFunderDepository(\\n        address owner,\\n        bytes32 root\\n    ) external returns (address payable merkleFunderDepository);\\n\\n    function fund(\\n        address owner,\\n        bytes32 root,\\n        bytes32[] calldata proof,\\n        address recipient,\\n        uint256 lowThreshold,\\n        uint256 highThreshold\\n    ) external returns (uint256 amount);\\n\\n    function withdraw(bytes32 root, address recipient, uint256 amount) external;\\n\\n    function withdrawAll(\\n        bytes32 root,\\n        address recipient\\n    ) external returns (uint256 amount);\\n\\n    function computeMerkleFunderDepositoryAddress(\\n        address owner,\\n        bytes32 root\\n    ) external view returns (address merkleFunderDepository);\\n\\n    function ownerToRootToMerkleFunderDepositoryAddress(\\n        address owner,\\n        bytes32 root\\n    ) external view returns (address payable merkleFunderDepository);\\n}\\n\",\"keccak256\":\"0x5fe89974c64a66ca607253cb2822cc8bb7aa9d689c2be6f278fab7207009dc24\",\"license\":\"MIT\"},\"contracts/interfaces/IMerkleFunderDepository.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IMerkleFunderDepository {\\n    error SenderNotMerkleFunder();\\n\\n    error TransferUnsuccessful();\\n\\n    function merkleFunder() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function root() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x37c209547fbd22f9aea047f066923f6b402e62694b8463c628145cc4bbb3a72f\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506113c8806100206000396000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063796b89b91161008c578063a6fb97d111610066578063a6fb97d1146101c8578063ac9650d8146101dd578063adb8e737146101fd578063f8b2cb4f1461022e57600080fd5b8063796b89b91461019c5780637997ccf3146101a257806390731b13146101b557600080fd5b8063437b9116116100c8578063437b91161461011d5780634be9b0441461013e5780634dcc19fe146101695780635989eaeb1461016f57600080fd5b80633408e470146100ef578063390317991461010457806342cbb15c14610117575b600080fd5b465b6040519081526020015b60405180910390f35b6100f1610112366004610cc9565b610249565b436100f1565b61013061012b366004610d4b565b61053f565b6040516100fb929190610e21565b61015161014c366004610e7a565b6106a5565b6040516001600160a01b0390911681526020016100fb565b486100f1565b61018c61017d366004610ea4565b6001600160a01b03163b151590565b60405190151581526020016100fb565b426100f1565b6101516101b0366004610e7a565b61079c565b6100f16101c3366004610ebf565b61083e565b6101db6101d6366004610eeb565b610872565b005b6101f06101eb366004610d4b565b6109ec565b6040516100fb9190610f20565b61015161020b366004610e7a565b60006020818152928152604080822090935290815220546001600160a01b031681565b6100f161023c366004610ea4565b6001600160a01b03163190565b60006001600160a01b038416610272576040516366736f6360e01b815260040160405180910390fd5b818311156102ac576040517f695d28a400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b816000036102e6576040517f48bfa51a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604080516001600160a01b03861660208201529081018490526060810183905260009060800160408051601f19818403018152828252805160209182012090830152016040516020818303038152906040528051906020012090506103818787808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152508c9250859150610b8b9050565b6103b7576040517f09bde33900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b03851631848111156103fc576040517f08dba7b400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b03808b166000908152602081815260408083208d8452909152902054168061043e5760405163cda47a2960e01b815260040160405180910390fd5b8185036001600160a01b0382163181111561046357816001600160a01b031631610465565b805b945084600003610488576040516365e52d5160e11b815260040160405180910390fd5b60405163a9059cbb60e01b81526001600160a01b0389811660048301526024820187905283169063a9059cbb90604401600060405180830381600087803b1580156104d257600080fd5b505af11580156104e6573d6000803e3d6000fd5b5050604080516001600160a01b038c81168252602082018a9052861693507f3b5083eec1a1116c56de5d6841cff8efc6a0aec9850e836ec509d6ce024ea56192500160405180910390a250505050979650505050505050565b606080828067ffffffffffffffff81111561055c5761055c610f33565b604051908082528060200260200182016040528015610585578160200160208202803683370190505b5092508067ffffffffffffffff8111156105a1576105a1610f33565b6040519080825280602002602001820160405280156105d457816020015b60608152602001906001900390816105bf5790505b50915060005b8181101561069c57308686838181106105f5576105f5610f49565b90506020028101906106079190610f5f565b604051610615929190610fa6565b600060405180830381855af49150503d8060008114610650576040519150601f19603f3d011682016040523d82523d6000602084013e610655565b606091505b5085838151811061066857610668610f49565b6020026020010185848151811061068157610681610f49565b602090810291909101019190915290151590526001016105da565b50509250929050565b6000816106c557604051636fe692dd60e11b815260040160405180910390fd5b6000801b83836040516106d790610c54565b6001600160a01b03909216825260208201526040018190604051809103906000f590508015801561070c573d6000803e3d6000fd5b506001600160a01b0384811660008181526020818152604080832088845282529182902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001694861694851790558151928352820186905292935090917fdaf781ca38299164d4878957537ed5f7e762b7e9d8d19be39979fb0a165c4684910160405180910390a292915050565b6000816107bc57604051636fe692dd60e11b815260040160405180910390fd5b604051610837906000906107d260208201610c54565b601f1982820381018352601f9091011660408181526001600160a01b0388166020830152810186905260600160408051601f198184030181529082905261081c9291602001610fb6565b60405160208183030381529060405280519060200120610ba1565b9392505050565b336000908152602081815260408083208584529091529020546001600160a01b03163161086c838383610872565b92915050565b6001600160a01b038216610899576040516366736f6360e01b815260040160405180910390fd5b806000036108ba576040516365e52d5160e11b815260040160405180910390fd5b336000908152602081815260408083208684529091529020546001600160a01b0316806108fa5760405163cda47a2960e01b815260040160405180910390fd5b81816001600160a01b031631101561093e576040517ff4d678b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60405163a9059cbb60e01b81526001600160a01b0384811660048301526024820184905282169063a9059cbb90604401600060405180830381600087803b15801561098857600080fd5b505af115801561099c573d6000803e3d6000fd5b5050604080516001600160a01b03878116825260208201879052851693507f0472be967f9a37138dfea1875af44784cafb79f92044ab33d7d6958eddd9ca6c92500160405180910390a250505050565b6060818067ffffffffffffffff811115610a0857610a08610f33565b604051908082528060200260200182016040528015610a3b57816020015b6060815260200190600190039081610a265790505b50915060005b81811015610b8357600030868684818110610a5e57610a5e610f49565b9050602002810190610a709190610f5f565b604051610a7e929190610fa6565b600060405180830381855af49150503d8060008114610ab9576040519150601f19603f3d011682016040523d82523d6000602084013e610abe565b606091505b50858481518110610ad157610ad1610f49565b6020908102919091010152905080610b7a576000848381518110610af757610af7610f49565b60200260200101519050600081511115610b145780518082602001fd5b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f4d756c746963616c6c3a204e6f2072657665727420737472696e670000000000604482015260640160405180910390fd5b50600101610a41565b505092915050565b600082610b988584610bae565b14949350505050565b6000610837838330610bfb565b600081815b8451811015610bf357610bdf82868381518110610bd257610bd2610f49565b6020026020010151610c25565b915080610beb81610fe5565b915050610bb3565b509392505050565b6000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b6000818310610c41576000828152602084905260409020610837565b6000838152602083905260409020610837565b6103868061100d83390190565b80356001600160a01b0381168114610c7857600080fd5b919050565b60008083601f840112610c8f57600080fd5b50813567ffffffffffffffff811115610ca757600080fd5b6020830191508360208260051b8501011115610cc257600080fd5b9250929050565b600080600080600080600060c0888a031215610ce457600080fd5b610ced88610c61565b965060208801359550604088013567ffffffffffffffff811115610d1057600080fd5b610d1c8a828b01610c7d565b9096509450610d2f905060608901610c61565b92506080880135915060a0880135905092959891949750929550565b60008060208385031215610d5e57600080fd5b823567ffffffffffffffff811115610d7557600080fd5b610d8185828601610c7d565b90969095509350505050565b60005b83811015610da8578181015183820152602001610d90565b50506000910152565b600082825180855260208086019550808260051b84010181860160005b84811015610e1457601f1980878503018a5282518051808652610df681888801898501610d8d565b9a86019a601f01909116939093018401925090830190600101610dce565b5090979650505050505050565b604080825283519082018190526000906020906060840190828701845b82811015610e5c578151151584529284019290840190600101610e3e565b50505083810382850152610e708186610db1565b9695505050505050565b60008060408385031215610e8d57600080fd5b610e9683610c61565b946020939093013593505050565b600060208284031215610eb657600080fd5b61083782610c61565b60008060408385031215610ed257600080fd5b82359150610ee260208401610c61565b90509250929050565b600080600060608486031215610f0057600080fd5b83359250610f1060208501610c61565b9150604084013590509250925092565b6020815260006108376020830184610db1565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112610f7657600080fd5b83018035915067ffffffffffffffff821115610f9157600080fd5b602001915036819003821315610cc257600080fd5b8183823760009101908152919050565b60008351610fc8818460208801610d8d565b835190830190610fdc818360208801610d8d565b01949350505050565b60006001820161100557634e487b7160e01b600052601160045260246000fd5b506001019056fe60e060405234801561001057600080fd5b5060405161038638038061038683398101604081905261002f9161004a565b336080526001600160a01b039190911660a05260c052610084565b6000806040838503121561005d57600080fd5b82516001600160a01b038116811461007457600080fd5b6020939093015192949293505050565b60805160a05160c0516102ce6100b8600039600061011501526000606101526000818160bf015261015d01526102ce6000f3fe6080604052600436106100435760003560e01c80638da5cb5b1461004f578063a8c54545146100ad578063a9059cbb146100e1578063ebf0c7171461010357600080fd5b3661004a57005b600080fd5b34801561005b57600080fd5b506100837f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b3480156100b957600080fd5b506100837f000000000000000000000000000000000000000000000000000000000000000081565b3480156100ed57600080fd5b506101016100fc366004610253565b610145565b005b34801561010f57600080fd5b506101377f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100a4565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146101b4576040517f7d5820a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d806000811461020e576040519150601f19603f3d011682016040523d82523d6000602084013e610213565b606091505b505090508061024e576040517f28dc5c3300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050565b6000806040838503121561026657600080fd5b823573ffffffffffffffffffffffffffffffffffffffff8116811461028a57600080fd5b94602093909301359350505056fea264697066735822122064ed49ef8d4b4d3f9725a7395b4ebf0f32e867e2dcc558528a1c1a023050fb1864736f6c63430008110033a26469706673582212201586d13ad0f88ec1b7bbe7f5b01547b0d09134ce3128c95e764b24d9649da0c664736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063796b89b91161008c578063a6fb97d111610066578063a6fb97d1146101c8578063ac9650d8146101dd578063adb8e737146101fd578063f8b2cb4f1461022e57600080fd5b8063796b89b91461019c5780637997ccf3146101a257806390731b13146101b557600080fd5b8063437b9116116100c8578063437b91161461011d5780634be9b0441461013e5780634dcc19fe146101695780635989eaeb1461016f57600080fd5b80633408e470146100ef578063390317991461010457806342cbb15c14610117575b600080fd5b465b6040519081526020015b60405180910390f35b6100f1610112366004610cc9565b610249565b436100f1565b61013061012b366004610d4b565b61053f565b6040516100fb929190610e21565b61015161014c366004610e7a565b6106a5565b6040516001600160a01b0390911681526020016100fb565b486100f1565b61018c61017d366004610ea4565b6001600160a01b03163b151590565b60405190151581526020016100fb565b426100f1565b6101516101b0366004610e7a565b61079c565b6100f16101c3366004610ebf565b61083e565b6101db6101d6366004610eeb565b610872565b005b6101f06101eb366004610d4b565b6109ec565b6040516100fb9190610f20565b61015161020b366004610e7a565b60006020818152928152604080822090935290815220546001600160a01b031681565b6100f161023c366004610ea4565b6001600160a01b03163190565b60006001600160a01b038416610272576040516366736f6360e01b815260040160405180910390fd5b818311156102ac576040517f695d28a400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b816000036102e6576040517f48bfa51a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604080516001600160a01b03861660208201529081018490526060810183905260009060800160408051601f19818403018152828252805160209182012090830152016040516020818303038152906040528051906020012090506103818787808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152508c9250859150610b8b9050565b6103b7576040517f09bde33900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b03851631848111156103fc576040517f08dba7b400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b03808b166000908152602081815260408083208d8452909152902054168061043e5760405163cda47a2960e01b815260040160405180910390fd5b8185036001600160a01b0382163181111561046357816001600160a01b031631610465565b805b945084600003610488576040516365e52d5160e11b815260040160405180910390fd5b60405163a9059cbb60e01b81526001600160a01b0389811660048301526024820187905283169063a9059cbb90604401600060405180830381600087803b1580156104d257600080fd5b505af11580156104e6573d6000803e3d6000fd5b5050604080516001600160a01b038c81168252602082018a9052861693507f3b5083eec1a1116c56de5d6841cff8efc6a0aec9850e836ec509d6ce024ea56192500160405180910390a250505050979650505050505050565b606080828067ffffffffffffffff81111561055c5761055c610f33565b604051908082528060200260200182016040528015610585578160200160208202803683370190505b5092508067ffffffffffffffff8111156105a1576105a1610f33565b6040519080825280602002602001820160405280156105d457816020015b60608152602001906001900390816105bf5790505b50915060005b8181101561069c57308686838181106105f5576105f5610f49565b90506020028101906106079190610f5f565b604051610615929190610fa6565b600060405180830381855af49150503d8060008114610650576040519150601f19603f3d011682016040523d82523d6000602084013e610655565b606091505b5085838151811061066857610668610f49565b6020026020010185848151811061068157610681610f49565b602090810291909101019190915290151590526001016105da565b50509250929050565b6000816106c557604051636fe692dd60e11b815260040160405180910390fd5b6000801b83836040516106d790610c54565b6001600160a01b03909216825260208201526040018190604051809103906000f590508015801561070c573d6000803e3d6000fd5b506001600160a01b0384811660008181526020818152604080832088845282529182902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001694861694851790558151928352820186905292935090917fdaf781ca38299164d4878957537ed5f7e762b7e9d8d19be39979fb0a165c4684910160405180910390a292915050565b6000816107bc57604051636fe692dd60e11b815260040160405180910390fd5b604051610837906000906107d260208201610c54565b601f1982820381018352601f9091011660408181526001600160a01b0388166020830152810186905260600160408051601f198184030181529082905261081c9291602001610fb6565b60405160208183030381529060405280519060200120610ba1565b9392505050565b336000908152602081815260408083208584529091529020546001600160a01b03163161086c838383610872565b92915050565b6001600160a01b038216610899576040516366736f6360e01b815260040160405180910390fd5b806000036108ba576040516365e52d5160e11b815260040160405180910390fd5b336000908152602081815260408083208684529091529020546001600160a01b0316806108fa5760405163cda47a2960e01b815260040160405180910390fd5b81816001600160a01b031631101561093e576040517ff4d678b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60405163a9059cbb60e01b81526001600160a01b0384811660048301526024820184905282169063a9059cbb90604401600060405180830381600087803b15801561098857600080fd5b505af115801561099c573d6000803e3d6000fd5b5050604080516001600160a01b03878116825260208201879052851693507f0472be967f9a37138dfea1875af44784cafb79f92044ab33d7d6958eddd9ca6c92500160405180910390a250505050565b6060818067ffffffffffffffff811115610a0857610a08610f33565b604051908082528060200260200182016040528015610a3b57816020015b6060815260200190600190039081610a265790505b50915060005b81811015610b8357600030868684818110610a5e57610a5e610f49565b9050602002810190610a709190610f5f565b604051610a7e929190610fa6565b600060405180830381855af49150503d8060008114610ab9576040519150601f19603f3d011682016040523d82523d6000602084013e610abe565b606091505b50858481518110610ad157610ad1610f49565b6020908102919091010152905080610b7a576000848381518110610af757610af7610f49565b60200260200101519050600081511115610b145780518082602001fd5b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f4d756c746963616c6c3a204e6f2072657665727420737472696e670000000000604482015260640160405180910390fd5b50600101610a41565b505092915050565b600082610b988584610bae565b14949350505050565b6000610837838330610bfb565b600081815b8451811015610bf357610bdf82868381518110610bd257610bd2610f49565b6020026020010151610c25565b915080610beb81610fe5565b915050610bb3565b509392505050565b6000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b6000818310610c41576000828152602084905260409020610837565b6000838152602083905260409020610837565b6103868061100d83390190565b80356001600160a01b0381168114610c7857600080fd5b919050565b60008083601f840112610c8f57600080fd5b50813567ffffffffffffffff811115610ca757600080fd5b6020830191508360208260051b8501011115610cc257600080fd5b9250929050565b600080600080600080600060c0888a031215610ce457600080fd5b610ced88610c61565b965060208801359550604088013567ffffffffffffffff811115610d1057600080fd5b610d1c8a828b01610c7d565b9096509450610d2f905060608901610c61565b92506080880135915060a0880135905092959891949750929550565b60008060208385031215610d5e57600080fd5b823567ffffffffffffffff811115610d7557600080fd5b610d8185828601610c7d565b90969095509350505050565b60005b83811015610da8578181015183820152602001610d90565b50506000910152565b600082825180855260208086019550808260051b84010181860160005b84811015610e1457601f1980878503018a5282518051808652610df681888801898501610d8d565b9a86019a601f01909116939093018401925090830190600101610dce565b5090979650505050505050565b604080825283519082018190526000906020906060840190828701845b82811015610e5c578151151584529284019290840190600101610e3e565b50505083810382850152610e708186610db1565b9695505050505050565b60008060408385031215610e8d57600080fd5b610e9683610c61565b946020939093013593505050565b600060208284031215610eb657600080fd5b61083782610c61565b60008060408385031215610ed257600080fd5b82359150610ee260208401610c61565b90509250929050565b600080600060608486031215610f0057600080fd5b83359250610f1060208501610c61565b9150604084013590509250925092565b6020815260006108376020830184610db1565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112610f7657600080fd5b83018035915067ffffffffffffffff821115610f9157600080fd5b602001915036819003821315610cc257600080fd5b8183823760009101908152919050565b60008351610fc8818460208801610d8d565b835190830190610fdc818360208801610d8d565b01949350505050565b60006001820161100557634e487b7160e01b600052601160045260246000fd5b506001019056fe60e060405234801561001057600080fd5b5060405161038638038061038683398101604081905261002f9161004a565b336080526001600160a01b039190911660a05260c052610084565b6000806040838503121561005d57600080fd5b82516001600160a01b038116811461007457600080fd5b6020939093015192949293505050565b60805160a05160c0516102ce6100b8600039600061011501526000606101526000818160bf015261015d01526102ce6000f3fe6080604052600436106100435760003560e01c80638da5cb5b1461004f578063a8c54545146100ad578063a9059cbb146100e1578063ebf0c7171461010357600080fd5b3661004a57005b600080fd5b34801561005b57600080fd5b506100837f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b3480156100b957600080fd5b506100837f000000000000000000000000000000000000000000000000000000000000000081565b3480156100ed57600080fd5b506101016100fc366004610253565b610145565b005b34801561010f57600080fd5b506101377f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100a4565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146101b4576040517f7d5820a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d806000811461020e576040519150601f19603f3d011682016040523d82523d6000602084013e610213565b606091505b505090508061024e576040517f28dc5c3300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050565b6000806040838503121561026657600080fd5b823573ffffffffffffffffffffffffffffffffffffffff8116811461028a57600080fd5b94602093909301359350505056fea264697066735822122064ed49ef8d4b4d3f9725a7395b4ebf0f32e867e2dcc558528a1c1a023050fb1864736f6c63430008110033a26469706673582212201586d13ad0f88ec1b7bbe7f5b01547b0d09134ce3128c95e764b24d9649da0c664736f6c63430008110033",
  "devdoc": {
    "details": "MerkleFunder inherits SelfMulticall to allow `fund()` to be multi-called so that multiple fundings can be executed in a single transaction without depending on an external contract. Furthermore, it inherits ExtendedSelfMulticall to allow `getBlockNumber()` be multi-called to avoid race conditions that would have caused the bot implementation to make redundant transactions that revert.",
    "kind": "dev",
    "methods": {
      "computeMerkleFunderDepositoryAddress(address,bytes32)": {
        "params": {
          "owner": "Owner address",
          "root": "Merkle tree root"
        },
        "returns": {
          "merkleFunderDepository": "MerkleFunderDepository address"
        }
      },
      "containsBytecode(address)": {
        "details": "An account not containing any bytecode does not indicate that it is an EOA or it will not contain any bytecode in the future. Contract construction and `SELFDESTRUCT` updates the bytecode at the end of the transaction.",
        "returns": {
          "_0": "If the account contains bytecode"
        }
      },
      "deployMerkleFunderDepository(address,bytes32)": {
        "details": "The owner address is allowed to be zero in case the deployer wants to disallow `withdraw()` from being called for the respective MerkleFunderDepository. See `fund()` for how the Merkle tree leaves are derived and how the comprising parameters are validated.",
        "params": {
          "owner": "Owner address",
          "root": "Merkle tree root"
        },
        "returns": {
          "merkleFunderDepository": "MerkleFunderDepository address"
        }
      },
      "fund(address,bytes32,bytes32[],address,uint256,uint256)": {
        "params": {
          "highThreshold": "High hysteresis threshold",
          "lowThreshold": "Low hysteresis threshold",
          "owner": "Owner address",
          "proof": "Merkle tree proof",
          "recipient": "Recipient address",
          "root": "Merkle tree root"
        },
        "returns": {
          "amount": "Amount used in funding"
        }
      },
      "getBalance(address)": {
        "params": {
          "account": "Account address"
        },
        "returns": {
          "_0": "Account balance"
        }
      },
      "getBlockBasefee()": {
        "returns": {
          "_0": "Current block basefee"
        }
      },
      "getBlockNumber()": {
        "returns": {
          "_0": "Current block number"
        }
      },
      "getBlockTimestamp()": {
        "returns": {
          "_0": "Current block timestamp"
        }
      },
      "getChainId()": {
        "returns": {
          "_0": "Chain ID"
        }
      },
      "multicall(bytes[])": {
        "params": {
          "data": "Array of calldata of batched calls"
        },
        "returns": {
          "returndata": "Array of returndata of batched calls"
        }
      },
      "tryMulticall(bytes[])": {
        "params": {
          "data": "Array of calldata of batched calls"
        },
        "returns": {
          "returndata": "Array of returndata of batched calls",
          "successes": "Array of success conditions of batched calls"
        }
      },
      "withdraw(bytes32,address,uint256)": {
        "params": {
          "amount": "Withdrawal amount",
          "recipient": "Recipient address",
          "root": "Merkle tree root"
        }
      },
      "withdrawAll(bytes32,address)": {
        "params": {
          "recipient": "Recipient address",
          "root": "Merkle tree root"
        },
        "returns": {
          "amount": "Withdrawal amount"
        }
      }
    },
    "stateVariables": {
      "ownerToRootToMerkleFunderDepositoryAddress": {
        "details": "The MerkleFunderDepository address can be derived from the owner address and the Merkle tree root using `computeMerkleFunderDepositoryAddress()`, yet doing so is more expensive than reading it from this mapping, which is why we prefer storing it during deployment"
      }
    },
    "title": "Contract that can be called to deploy MerkleFunderDepository contracts or transfer the funds in them within the limitations specified by the respective Merkle trees",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "computeMerkleFunderDepositoryAddress(address,bytes32)": {
        "notice": "Computes the address of the MerkleFunderDepository"
      },
      "containsBytecode(address)": {
        "notice": "Returns if the account contains bytecode"
      },
      "deployMerkleFunderDepository(address,bytes32)": {
        "notice": "Called to deterministically deploy the MerkleFunderDepository with the owner address and the Merkle tree root"
      },
      "fund(address,bytes32,bytes32[],address,uint256,uint256)": {
        "notice": "Called to transfer funds from a MerkleFunderDepository to the recipient within the limitations specified by the respective Merkle tree"
      },
      "getBalance(address)": {
        "notice": "Returns the account balance"
      },
      "getBlockBasefee()": {
        "notice": "Returns the current block basefee"
      },
      "getBlockNumber()": {
        "notice": "Returns the current block number"
      },
      "getBlockTimestamp()": {
        "notice": "Returns the current block timestamp"
      },
      "getChainId()": {
        "notice": "Returns the chain ID"
      },
      "multicall(bytes[])": {
        "notice": "Batches calls to the inheriting contract and reverts as soon as one of the batched calls reverts"
      },
      "ownerToRootToMerkleFunderDepositoryAddress(address,bytes32)": {
        "notice": "Returns the address of the MerkleFunderDepository deployed for the owner address and the Merkle tree root, and zero-address if such a MerkleFunderDepository is not deployed yet"
      },
      "tryMulticall(bytes[])": {
        "notice": "Batches calls to the inheriting contract but does not revert if any of the batched calls reverts"
      },
      "withdraw(bytes32,address,uint256)": {
        "notice": "Called by the owner of the respective MerkleFunderDepository to withdraw funds in a way that is exempt from the limitations specified by the respective Merkle tree"
      },
      "withdrawAll(bytes32,address)": {
        "notice": "Called by the owner of the respective MerkleFunderDepository to withdraw its entire balance in a way that is exempt from the limitations specified by the respective Merkle tree"
      }
    },
    "notice": "Use-cases such as self-funded data feeds require users to keep multiple accounts funded. The only way to achieve this without relying on on-chain activity is running a bot that triggers the funding using a hot wallet. In the naive implementation, the funds to be used would also be kept by this hot wallet, which is obviously risky. This contract allows one to deploy a MerkleFunderDepository where they can keep the funds, which this contract only allows to be transferred within the limitations specified by the respective Merkle tree. This means the bot's hot wallet no longer needs to be trusted with the funds, and multiple bots with different hot wallets can be run against the same MerkleFunderDepository deployment for redundancy.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 902,
        "contract": "contracts/MerkleFunder.sol:MerkleFunder",
        "label": "ownerToRootToMerkleFunderDepositoryAddress",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_mapping(t_bytes32,t_address_payable))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_address_payable": {
        "encoding": "inplace",
        "label": "address payable",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_mapping(t_bytes32,t_address_payable))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(bytes32 => address payable))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_address_payable)"
      },
      "t_mapping(t_bytes32,t_address_payable)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => address payable)",
        "numberOfBytes": "32",
        "value": "t_address_payable"
      }
    }
  }
}